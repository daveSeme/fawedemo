<?php
/*
 * @ https://EasyToYou.eu - IonCube v10 Decoder Online
 * @ PHP 7.2
 * @ Decoder version: 1.0.4
 * @ Release: 01/09/2021
 */

echo "<script src=\"https://code.highcharts.com/highcharts.js\"></script>\r\n<script src=\"";
echo base_url();
echo "/public/js/table/jquery.highchartTable-min.js\"></script>\r\n<script src=\"https://code.highcharts.com/highcharts-more.js\"></script>\r\n<script src=\"https://code.highcharts.com/modules/exporting.js\"></script>\r\n<script src=\"https://code.highcharts.com/modules/export-data.js\"></script>\r\n<script src=\"https://code.highcharts.com/modules/accessibility.js\"></script>\r\n\r\n<script src=\"";
echo base_url();
echo "/public/js/wicket/wicket.js\" type=\"text/javascript\"></script>\r\n<script src=\"";
echo base_url();
echo "/public/js/wicket/wicket-gmap3.js\" type=\"text/javascript\"></script>\r\n\r\n\r\n<!--<script src=\"https://code.highcharts.com/highcharts.js\"></script>\r\n<script src=\"https://code.highcharts.com/highcharts-more.js\"></script>\r\n<script src=\"https://code.highcharts.com/modules/exporting.js\"></script>\r\n<script src=\"https://code.highcharts.com/modules/export-data.js\"></script>\r\n<script src=\"https://code.highcharts.com/modules/accessibility.js\"></script>\r\n-->\r\n\r\n\r\n<input type='hidden' id='wkt' value='' />\r\n\r\n<script type=\"text/javascript\">\r\n\t\$(document).ready(function() {\r\n\t// \$('table.highchart').highchartTable();\r\n\t\$('table.highchart')\r\n\t  .bind('highchartTable.beforeRender', function(event, highChartConfig) {\r\n\t\thighChartConfig.colors = ['#0000FF', '#008000', '#FFFF00', '#FF0000', '#FFD700', '#3399CC'];\r\n\t  })\r\n\t  .highchartTable();\r\n\t  \r\n\t\t\t\t\t\r\n\t})\r\n</script>\r\n\r\n\r\n<script type=\"text/javascript\">\r\n\r\n\t\tHighcharts.chart('container', {\r\n\t\t\r\n\t\t  chart: {\r\n\t\t\ttype: 'gauge',\r\n\t\t\tplotBackgroundColor: null,\r\n\t\t\tplotBackgroundImage: null,\r\n\t\t\tplotBorderWidth: 0,\r\n\t\t\tplotShadow: false\r\n\t\t  },\r\n\t\t\r\n\t\t  title: {\r\n\t\t\ttext: 'Annual Output Performace'\r\n\t\t  },\r\n\t\t\r\n\t\t  pane: {\r\n\t\t\tstartAngle: -150,\r\n\t\t\tendAngle: 150,\r\n\t\t\tbackground: [{\r\n\t\t\t  backgroundColor: {\r\n\t\t\t\tlinearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },\r\n\t\t\t\tstops: [\r\n\t\t\t\t  [0, '#FFF'],\r\n\t\t\t\t  [1, '#333']\r\n\t\t\t\t]\r\n\t\t\t  },\r\n\t\t\t  borderWidth: 0,\r\n\t\t\t  outerRadius: '109%'\r\n\t\t\t}, {\r\n\t\t\t  backgroundColor: {\r\n\t\t\t\tlinearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },\r\n\t\t\t\tstops: [\r\n\t\t\t\t  [0, '#333'],\r\n\t\t\t\t  [1, '#FFF']\r\n\t\t\t\t]\r\n\t\t\t  },\r\n\t\t\t  borderWidth: 1,\r\n\t\t\t  outerRadius: '107%'\r\n\t\t\t}, {\r\n\t\t\t  // default background\r\n\t\t\t}, {\r\n\t\t\t  backgroundColor: '#DDD',\r\n\t\t\t  borderWidth: 0,\r\n\t\t\t  outerRadius: '105%',\r\n\t\t\t  innerRadius: '103%'\r\n\t\t\t}]\r\n\t\t  },\r\n\t\t\r\n\t\t  // the value axis\r\n\t\t  yAxis: {\r\n\t\t\tmin: 0,\r\n\t\t\tmax: 200,\r\n\t\t\r\n\t\t\tminorTickInterval: 'auto',\r\n\t\t\tminorTickWidth: 1,\r\n\t\t\tminorTickLength: 10,\r\n\t\t\tminorTickPosition: 'inside',\r\n\t\t\tminorTickColor: '#666',\r\n\t\t\r\n\t\t\ttickPixelInterval: 30,\r\n\t\t\ttickWidth: 2,\r\n\t\t\ttickPosition: 'inside',\r\n\t\t\ttickLength: 10,\r\n\t\t\ttickColor: '#666',\r\n\t\t\tlabels: {\r\n\t\t\t  step: 2,\r\n\t\t\t  rotation: 'auto'\r\n\t\t\t},\r\n\t\t\ttitle: {\r\n\t\t\t  text: 'km/h'\r\n\t\t\t},\r\n\t\t\tplotBands: [{\r\n\t\t\t  from: 0,\r\n\t\t\t  to: 120,\r\n\t\t\t  color: '#55BF3B' // green\r\n\t\t\t}, {\r\n\t\t\t  from: 120,\r\n\t\t\t  to: 160,\r\n\t\t\t  color: '#DDDF0D' // yellow\r\n\t\t\t}, {\r\n\t\t\t  from: 160,\r\n\t\t\t  to: 200,\r\n\t\t\t  color: '#DF5353' // red\r\n\t\t\t}]\r\n\t\t  },\r\n\t\t\r\n\t\t  series: [{\r\n\t\t\tname: 'Speed',\r\n\t\t\tdata: [80],\r\n\t\t\ttooltip: {\r\n\t\t\t  valueSuffix: ' km/h'\r\n\t\t\t}\r\n\t\t  }]\r\n\t\t\r\n\t\t},\r\n\t\t// Add some life\r\n\t\tfunction (chart) {\r\n\t\t  if (!chart.renderer.forExport) {\r\n\t\t\tsetInterval(function () {\r\n\t\t\t  var point = chart.series[0].points[0],\r\n\t\t\t\tnewVal,\r\n\t\t\t\tinc = Math.round((Math.random() - 0.5) * 20);\r\n\t\t\r\n\t\t\t  newVal = point.y + inc;\r\n\t\t\t  if (newVal < 0 || newVal > 200) {\r\n\t\t\t\tnewVal = point.y - inc;\r\n\t\t\t  }\r\n\t\t\r\n\t\t\t  point.update(newVal);\r\n\t\t\r\n\t\t\t}, 3000);\r\n\t\t  }\r\n\t\t});\r\n\r\n//////////////////////////////////////////////////////\r\nHighcharts.chart('container_2', {\r\n\r\n    chart: {\r\n        type: 'gauge',\r\n        plotBackgroundColor: null,\r\n        plotBackgroundImage: null,\r\n        plotBorderWidth: 0,\r\n        plotShadow: false\r\n    },\r\n\r\n    title: {\r\n        text: '7NDP OUTPUT PERFORMANCE TO DATE'\r\n    },\r\n\r\n    pane: {\r\n        startAngle: -150,\r\n        endAngle: 150,\r\n        background: [{\r\n            backgroundColor: {\r\n                linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },\r\n                stops: [\r\n                    [0, '#FFF'],\r\n                    [1, '#333']\r\n                ]\r\n            },\r\n            borderWidth: 0,\r\n            outerRadius: '109%'\r\n        }, {\r\n            backgroundColor: {\r\n                linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },\r\n                stops: [\r\n                    [0, '#333'],\r\n                    [1, '#FFF']\r\n                ]\r\n            },\r\n            borderWidth: 1,\r\n            outerRadius: '107%'\r\n        }, {\r\n            // default background\r\n        }, {\r\n            backgroundColor: '#DDD',\r\n            borderWidth: 0,\r\n            outerRadius: '105%',\r\n            innerRadius: '103%'\r\n        }]\r\n    },\r\n\r\n    // the value axis\r\n    yAxis: {\r\n        min: 0,\r\n        max: 100,\r\n\r\n        minorTickInterval: 'auto',\r\n        minorTickWidth: 1,\r\n        minorTickLength: 10,\r\n        minorTickPosition: 'inside',\r\n        minorTickColor: '#666',\r\n\r\n        tickPixelInterval: 30,\r\n        tickWidth: 2,\r\n        tickPosition: 'inside',\r\n        tickLength: 10,\r\n        tickColor: '#666',\r\n        labels: {\r\n            step: 2,\r\n            rotation: 'auto'\r\n        },\r\n        title: {\r\n            text: 'Output'\r\n        },\r\n          plotBands: [{\r\n            from: 0,\r\n            to: 49,\r\n            color: '#DF5353' // red\r\n        }, {\r\n            from: 49,\r\n            to: 75,\r\n            color: '#DDDF0D' // yellow\r\n        }, {\r\n            from: 75,\r\n            to: 100,\r\n            color: '#55BF3B' // green\r\n        }]\r\n    },\r\n\r\n\r\n\r\n    series: [{\r\n        name: 'Output Performance to Completion',\r\n       data: [15.36],\r\n        tooltip: {\r\n            valueSuffix: '% Achivement'\r\n        }\r\n\t\t\r\n    }]\r\n\r\n});\r\n\r\n////annual\r\n\t\t \r\n\r\n</script>\r\n<script>\r\n    jQuery(function (\$) {\r\n//        \$(\"#field-MapLocation\").attr('readonly','readonly');\r\n\r\n        // Asynchronously Load the map API \r\n        if (\$(\"#googleMapScript\")) {\r\n            window.google = {};\r\n            if (\$(\"#field-MapLocation\").is(\"div\")) {\r\n                \$(\"#wkt\").val(\$(\"#field-MapLocation\").text());\r\n            } else {\r\n                \$(\"#wkt\").val(\$(\"#field-MapLocation\").val());\r\n            }\r\n        }\r\n\r\n        var script = document.createElement('script');\r\n\r\n        script.src = \"//maps.googleapis.com/maps/api/js?libraries=drawing&callback=initialize&key=AIzaSyAQmJi4FYMhR8nK-ntwuVoWjVtNWMgi2XA\";\r\n        script.id = \"googleMapScript\";\r\n\r\n        document.body.appendChild(script);\r\n        \$(\"#field-MapLocation\").on(\"change\", function () {\r\n            \$(\"#wkt\").val(\$(\"#field-MapLocation\").val());\r\n            app.clearMap();\r\n            app.mapIt();\r\n        });\r\n\r\n        \$(\"#wkt\").on(\"change\", function () {\r\n            \$(\"#field-MapLocation\").val(\$(\"#wkt\").val());\r\n        });\r\n    });\r\n\r\n    var app = (function () {\r\n        return {\r\n            features: [],\r\n            /**\r\n             * Clears the map contents.\r\n             */\r\n            clearMap: function () {\r\n                var i;\r\n\r\n                // Reset the remembered last string (so that we can clear the map,\r\n                //  paste the same string, and see it again)\r\n                document.getElementById('wkt').last = '';\r\n\r\n                for (i in this.features) {\r\n                    if (this.features.hasOwnProperty(i)) {\r\n                        this.features[i].setMap(null);\r\n                    }\r\n                }\r\n                this.features.length = 0;\r\n            },\r\n            /**\r\n             * Clears the current contents of the textarea.\r\n             */\r\n            clearText: function () {\r\n                //            console.log('clearText called');\r\n                document.getElementById('wkt').value = '';\r\n            },\r\n            /**\r\n             * Maps the current contents of the textarea.\r\n             * @return  {Object}    Some sort of geometry object\r\n             */\r\n            mapIt: function () {\r\n                var el, obj, wkt;\r\n\r\n                el = document.getElementById('wkt');\r\n                wkt = new Wkt.Wkt();\r\n\r\n                if (el.last === el.value) { // Remember the last string\r\n                    return; // Do nothing if the WKT string hasn't changed\r\n                } else {\r\n                    el.last = el.value;\r\n                }\r\n\r\n                try { // Catch any malformed WKT strings\r\n                    wkt.read(el.value);\r\n                } catch (e1) {\r\n                    try {\r\n                        wkt.read(el.value.replace('\\n', '').replace('\\r', '').replace('\\t', ''));\r\n                    } catch (e2) {\r\n                        if (e2.name === 'WKTError') {\r\n                            alert('Wicket could not understand the WKT string you entered. Check that you have parentheses balanced, and try removing tabs and newline characters.');\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                obj = wkt.toObject(this.gmap.defaults); // Make an object\r\n\r\n                // Add listeners for overlay editing events\r\n                if (!Wkt.isArray(obj) && wkt.type !== 'point') {\r\n                    // New vertex is inserted\r\n                    google.maps.event.addListener(obj.getPath(), 'insert_at', function (n) {\r\n                        app.updateText();\r\n                    });\r\n                    // Existing vertex is removed (insertion is undone)\r\n                    google.maps.event.addListener(obj.getPath(), 'remove_at', function (n) {\r\n                        app.updateText();\r\n                    });\r\n                    // Existing vertex is moved (set elsewhere)\r\n                    google.maps.event.addListener(obj.getPath(), 'set_at', function (n) {\r\n                        app.updateText();\r\n                    });\r\n                } else {\r\n                    if (obj.setEditable) {\r\n                        obj.setEditable(false);\r\n                    }\r\n                }\r\n\r\n                var bounds = new google.maps.LatLngBounds();\r\n\r\n                if (Wkt.isArray(obj)) { // Distinguish multigeometries (Arrays) from objects\r\n                    for (i in obj) {\r\n                        if (obj.hasOwnProperty(i) && !Wkt.isArray(obj[i])) {\r\n                            obj[i].setMap(this.gmap);\r\n                            this.features.push(obj[i]);\r\n\r\n                            if (wkt.type === 'point' || wkt.type === 'multipoint')\r\n                                bounds.extend(obj[i].getPosition());\r\n                            else\r\n                                obj[i].getPath().forEach(function (element, index) {\r\n                                    bounds.extend(element)\r\n                                });\r\n                        }\r\n                    }\r\n\r\n                    this.features = this.features.concat(obj);\r\n                } else {\r\n                    obj.setMap(this.gmap); // Add it to the map\r\n                    this.features.push(obj);\r\n\r\n                    if (wkt.type === 'point' || wkt.type === 'multipoint')\r\n                        bounds.extend(obj.getPosition());\r\n                    else\r\n                        obj.getPath().forEach(function (element, index) {\r\n                            bounds.extend(element)\r\n                        });\r\n                }\r\n\r\n                // Pan the map to the feature\r\n//                this.gmap.fitBounds(bounds);\r\n\r\n                zoomChangeBoundsListener =\r\n                        google.maps.event.addListenerOnce(this.gmap, 'bounds_changed', function (event) {\r\n                            if (this.getZoom()) {\r\n                                var z = parseInt(\"6\");\r\n                                this.setZoom(z);\r\n                            }\r\n                        });\r\n\r\n                google.maps.event.addListener(this.gmap, 'zoom_changed', function () {\r\n                    zoomLevel = this.getZoom();\r\n                    if (zoomLevel > 1)\r\n                        \$(\"#zoom_level\").val(zoomLevel);\r\n                });\r\n\r\n                return obj;\r\n            },\r\n            /**\r\n             * Updates the textarea based on the first available feature.\r\n             */\r\n            updateText: function () {\r\n                var wkt = new Wkt.Wkt();\r\n                wkt.fromObject(this.features[0]);\r\n\r\n                document.getElementById('field-MapLocation').value = wkt.write();\r\n                document.getElementById('wkt').value = wkt.write();\r\n            },\r\n\r\n            updateTextPart: function () {\r\n                var i, w, v;\r\n\r\n                try {\r\n                    w = new Wkt.Wkt();\r\n                    w.fromObject(this.features[0]);\r\n\r\n                    i = 1;\r\n                    while (i < this.features.length) {\r\n                        v = new Wkt.Wkt(this.features[i]);\r\n                        w.merge(v);\r\n                        i += 1;\r\n                    }\r\n\r\n                    document.getElementById('field-MapLocation').value = w.write();\r\n                    document.getElementById('wkt').value = w.write();\r\n                } catch (e) {\r\n\r\n                    if (confirm(\"Only similar shapes can be merged. \\nDo you want to clear existing Map Location?\")) {\r\n                        app.clearText();\r\n                        app.clearMap();\r\n                    }\r\n                    ;\r\n\r\n                    this.features.pop().setMap(null);\r\n                }\r\n            },\r\n            /**\r\n             * Formats the textarea contents for a URL.\r\n\r\n             * @param   checked {Boolean}   The check state of the associated checkbox\r\n             */\r\n            urlify: function (checked) {\r\n                var wkt = new Wkt.Wkt();\r\n                wkt.read(document.getElementById('wkt').value);\r\n                wkt.delimiter = (checked) ? '+' : ' ';\r\n                document.getElementById('wkt').value = wkt.write();\r\n                return wkt;\r\n            },\r\n            /**\r\n             * Application entry point.\r\n             * @return  {<google.maps.Map>} The Google Maps API instance\r\n             */\r\n            init: function () {\r\n                //            console.log('init called');\r\n                var gmap;\r\n\r\n                gmap = new google.maps.Map(document.getElementById('map'), {\r\n                    center: new google.maps.LatLng(5.23,  50),\r\n                    defaults: {\r\n                        editable: false,\r\n                        strokeColor: '#990000',\r\n                        fillColor: '#EEFFCC',\r\n                        fillOpacity: 0.6\r\n                    },\r\n                    disableDefaultUI: true,\r\n                    mapTypeControl: true,\r\n                    mapTypeId: google.maps.MapTypeId.ROADMAP,\r\n                    mapTypeControlOptions: {\r\n                        position: google.maps.ControlPosition.TOP_LEFT,\r\n                        style: google.maps.MapTypeControlStyle.DROPDOWN_MENU\r\n                    },\r\n                    panControl: false,\r\n                    streetViewControl: false,\r\n                    zoom: 6,\r\n                    zoomControl: true,\r\n                    zoomControlOptions: {\r\n                        position: google.maps.ControlPosition.LEFT_TOP,\r\n                        style: google.maps.ZoomControlStyle.SMALL\r\n                    }\r\n                });\r\n\r\n                // Create the DIV to hold the control and call the CenterControl()\r\n                // constructor passing in this DIV.\r\n                var centerControlDiv = document.createElement('div');\r\n                var centerControl = new CenterControl(centerControlDiv, gmap);\r\n\r\n                centerControlDiv.index = 1;\r\n                gmap.controls[google.maps.ControlPosition.TOP_RIGHT].push(centerControlDiv);\r\n\r\n                google.maps.event.addListener(gmap, 'tilesloaded', function () {\r\n                    //                console.log('tilesloaded called');\r\n                    if (!this.loaded) {\r\n                        this.loaded = true;\r\n                        // NOTE: We start with a MULTIPOLYGON; these aren't easily deconstructed, so we won't set this object to be editable in this example\r\n                        //document.getElementById('wkt').value = 'MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)), ((20 35, 10 30, 10 10, 30 5, 45 20, 20 35), (30 20, 20 15, 20 25, 30 20)))';\r\n                        app.mapIt();\r\n                    }\r\n                });\r\n\r\n\r\n                var gc_state = \"read\";\r\n\r\n                if (gc_state == \"edit\" || gc_state == \"update\" || gc_state == \"update_validation\"\r\n                        || gc_state == \"add\" || gc_state == \"insert\" || gc_state == \"insert_validation\") {\r\n\r\n                    gmap.drawingManager = new google.maps.drawing.DrawingManager({\r\n                        drawingMode: google.maps.drawing.OverlayType.POLYLINE,\r\n                        drawingControl: true,\r\n                        drawingControlOptions: {\r\n                            position: google.maps.ControlPosition.TOP_CENTER,\r\n                            drawingModes: ['marker', 'circle', 'polygon', 'polyline', 'rectangle']\r\n                        },\r\n                        polygonOptions: {\r\n                            editable: true\r\n                        },\r\n                        polygonOptions: gmap.defaults,\r\n                        polylineOptions: gmap.defaults,\r\n                        rectangleOptions: gmap.defaults,\r\n                        circleOptions: gmap.defaults\r\n                    });\r\n\r\n                    gmap.drawingManager.setMap(gmap);\r\n\r\n                    gmap.overlayClickListener = function (overlay) {\r\n                        google.maps.event.addListener(overlay, \"mouseup\", function (event) {\r\n                            console.log(overlay.getPath().getArray());\r\n                        });\r\n                    }\r\n\r\n                    google.maps.event.addListener(gmap.drawingManager, \"overlaycomplete\", function (event) {\r\n                        var newShape = event.overlay;\r\n                        newShape.type = event.type;\r\n                    });\r\n\r\n                    google.maps.event.addListener(gmap.drawingManager, 'overlaycomplete', function (event) {\r\n                        //                console.log('overlaycomplete called');\r\n                        var wkt;\r\n\r\n                        //app.clearText();\r\n                        //app.clearMap();\r\n\r\n                        // Set the drawing mode to \"pan\" (the hand) so users can immediately edit\r\n                        this.setDrawingMode(null);\r\n\r\n                        // Polygon drawn\r\n                        if (event.type === google.maps.drawing.OverlayType.POLYGON || event.type === google.maps.drawing.OverlayType.POLYLINE) {\r\n                            // New vertex is inserted\r\n                            google.maps.event.addListener(event.overlay.getPath(), 'insert_at', function (n) {\r\n                                app.updateText();\r\n                            });\r\n\r\n                            // Existing vertex is removed (insertion is undone)\r\n                            google.maps.event.addListener(event.overlay.getPath(), 'remove_at', function (n) {\r\n                                app.updateText();\r\n                            });\r\n\r\n                            // Existing vertex is moved (set elsewhere)\r\n                            google.maps.event.addListener(event.overlay.getPath(), 'set_at', function (n) {\r\n                                app.updateText();\r\n                            });\r\n                        } else if (event.type === google.maps.drawing.OverlayType.RECTANGLE) { // Rectangle drawn\r\n                            // Listen for the 'bounds_changed' event and update the geometry\r\n                            google.maps.event.addListener(event.overlay, 'bounds_changed', function () {\r\n                                app.updateText();\r\n                            });\r\n                        }\r\n\r\n                        app.features.push(event.overlay);\r\n\r\n                        wkt = new Wkt.Wkt();\r\n                        wkt.fromObject(event.overlay);\r\n\r\n                        app.updateTextPart();\r\n                    });\r\n                }\r\n\r\n                return gmap;\r\n            }\r\n        };\r\n    }()); // Execute immediately\r\n\r\n    /**\r\n     * The CenterControl adds a control to the map that recenters the map on\r\n     * Chicago.\r\n     * This constructor takes the control DIV as an argument.\r\n     * @constructor\r\n     */\r\n    function CenterControl(controlDiv, map) {\r\n\r\n        // Set CSS for the control border.\r\n        var controlUI = document.createElement('div');\r\n        controlUI.className = \"fullscreen_toggle\";\r\n        controlUI.style.backgroundColor = '#fff';\r\n        controlUI.style.border = '2px solid #fff';\r\n        controlUI.style.borderRadius = '3px';\r\n        controlUI.style.boxShadow = '0 2px 6px rgba(0,0,0,.3)';\r\n        controlUI.style.cursor = 'pointer';\r\n        controlUI.style.marginTop = '10px';\r\n        controlUI.style.marginRight = '10px';\r\n        controlUI.style.marginBottom = '22px';\r\n        controlUI.style.textAlign = 'center';\r\n        controlUI.title = 'Toggle fullscreen';\r\n        controlDiv.appendChild(controlUI);\r\n\r\n        // Set CSS for the control interior.\r\n        var controlText = document.createElement('div');\r\n        controlText.style.color = 'rgb(25,25,25)';\r\n        controlText.style.fontFamily = 'Roboto,Arial,sans-serif';\r\n        controlText.style.fontSize = '16px';\r\n        controlText.style.lineHeight = '38px';\r\n        controlText.style.paddingLeft = '5px';\r\n        controlText.style.paddingRight = '5px';\r\n        controlText.innerHTML = 'Toggle fullscreen';\r\n        controlUI.appendChild(controlText);\r\n\r\n        // Setup the click event listeners: simply set the map to Chicago.\r\n        controlUI.addEventListener('click', function () {\r\n            \$(\"#map\").toggleClass(\"fullscreen\");\r\n            google.maps.event.trigger(map, 'resize');\r\n            //map.setCenter(newyork);\r\n\r\n            return false;\r\n        });\r\n    }\r\n\r\n    function initialize() {\r\n        app.gmap = app.init();\r\n        app.clearMap();\r\n        app.mapIt();\r\n    }\r\n\r\n    \$(\".mapOnClick\").click(function () {\r\n        setTimeout(function () {\r\n            initialize();\r\n        }, 2000);\r\n    });\r\n</script>";

?>